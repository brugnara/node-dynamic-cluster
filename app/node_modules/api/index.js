/**
 * Created by brugnara on 15/04/2017,
 * @ daniele@brugnara.me
 */

'use strict';

const Debug = require('debug');
const debug = Debug('node-dynamic-cluster:index');
debug.verbose = Debug('verbose:node-dynamic-cluster:index');

const cluster = require('cluster');
const http = require('http');
const url = require('url');

module.exports = function Api(options) {

  if (!(this instanceof Api)) {
    return new Api(options);
  }
  options = options || {};
  //
  let size = options.clusterSize;
  const port = options.port;
  const maxSize = options.maxSize || 64;
  const host = options.host || '0.0.0.0';

  const app = http.createServer((req, res) => {
    const urlParts = url.parse(req.url);

    debug.verbose(req.url, urlParts);

    const matchResize = /\/scale\/(\d*)$/i.exec(urlParts.pathname);
    debug.verbose('matchResize result: %j', matchResize);

    const matchInfo = /\/scale$/i.exec(urlParts.pathname);
    debug.verbose('matchInfo result: %j', matchInfo);

    let _count;

    res.writeHead(200, {'Content-Type': 'application/json'});

    if (matchResize) {
      _count = +matchResize[1];

      if (maxSize && _count > maxSize) {
        return res.end(JSON.stringify({
          status: 'ko',
          error: `wanted size (${_count}) exceed the maxSize (${maxSize})`
        }));
      }

      if (_count !== size && _count > 0) {
        debug(`changing count to ${_count}`);
        size = _count;
        update();
      } else {
        debug('skipping resize');
      }

      return res.end(JSON.stringify({
        status: 'ok',
        data:size
      }))
    }

    if (matchInfo) {
      return res.end(JSON.stringify({
        status: 'ok',
        data: size
      }))
    }

    debug(match);

    res.end('ok');
  });

  function update() {

    const currentWorkers = Object.keys(cluster.workers).length;

    if (currentWorkers < size) {
      debug(`starting ${size - currentWorkers} workers..`);

      let i = currentWorkers;

      while (i++ < size) {
        const worker = cluster.fork();
        debug(`${i}/${size} worker ${worker.id} is starting..`);
      }

      return;
    }

    if (currentWorkers > size) {
      const dieingWorkers = Object.keys(cluster.workers).slice(-1 * (currentWorkers - size));
      // kill some worker
      dieingWorkers.forEach(id => {
        debug(`killing worker ${id}`);
        cluster.workers[id].kill(0);
      });
      return;
    }
  }

  return {

    listen: function (cb) {

      app.listen(port, host, () => {
        debug(`api server listening on port ${port}`);
        cb && cb();
      });

      update();

      cluster.on('exit', (worker, code, signal) => {
        debug(`worker ${worker.id} (pid: ${worker.process.pid}) died with: ${signal || code}.`);

        if (code !== 0 && signal !== 'SIGTERM') {
          const newWorker = cluster.fork();
          debug(`restarting worker ${newWorker.id} due code = ${code}..`);
        }
      });
    }

  };
};
